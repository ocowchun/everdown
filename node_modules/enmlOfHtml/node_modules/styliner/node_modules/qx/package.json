{
  "name": "qx",
  "version": "0.2.4",
  "description": "A set of LINQ-like extensions to Q for working with arrays of promises.",
  "homepage": "https://github.com/SLaks/Qx",
  "author": {
    "name": "Schabse Laks",
    "email": "Dev@SLaks.net",
    "url": "http://slaks.net"
  },
  "keywords": [
    "q",
    "promises",
    "linq",
    "arrays"
  ],
  "main": "Qx.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/SLaks/Qx.git"
  },
  "license": "MIT",
  "scripts": {
    "test": "mocha",
    "lint": "jshint Qx.js"
  },
  "dependencies": {
    "q": ">=0.8.12"
  },
  "devDependencies": {
    "mocha": "~1.8.1",
    "mocha-as-promised": "~1.2.1",
    "jshint": "~0.9.1"
  },
  "readme": "#Qx [![Build Status](https://travis-ci.org/SLaks/Qx.png)](https://travis-ci.org/SLaks/Qx)\r\n\r\n\r\nQx is a set of extensions to [Q](https://github.com/kriskowal/q) that make it easier to work with promises of arrays of promises.\r\n\r\nQx brings the convenience of C# LINQ methods to Javascript promise arrays.\r\n\r\n##Usage\r\nAll Qx array methods take an array and a callback function that does things to items in the array. \r\n\r\nAll callbacks receive two parameters; the item and its index.  If the array contains promises, Qx will wait for those promises to finish and pass their values to the callback.  If the callback itself returns a promise, Qx will wait for it to finish too.\r\n\r\nThere are four ways to call these functions:\r\n\r\n 1. You can also pass an array and a callback directly: (this is useful if the array is not a promise)\r\n```js\r\nvar filenames = process.argv;\r\nQx.filter(filenames, qfs.isFile)\r\n  .then(function(array) {\r\n\t  ...\r\n  });\r\n```\r\n\r\n 2. You can pass an array of callbacks, and the Qx method will call each callback with only an index parameter: (this is useful if you have an array of functions that return promises)\r\n```js\r\nvar functions = [\r\n\tfunction() { return  somePromise; },\r\n\tfunction() { return otherPromise; },\r\n];\r\nQx.map(functions)\r\n  .then(function(results) {\r\n\t  ...;\r\n  });\r\n```\r\n\r\n 3. You can pass a callback only, and the Qx method will return a function that takes an array as a parameter (like #1): (this is useful if you only have a promise of the array; you can pass the Qx call directly to `.then()`)\r\n```js\r\nqfs.list('.')\r\n   .then(Qx.filter(qfs.isDirectory))\r\n   .then(Qx.map(function(d) { return require('./' + d); }))\r\n```\r\n\r\n 4. You can pass no arguments, and the Qx method will return a function that expects an array of callbacks (like #2): (this is useful if you have a promise of an array of functions that return promises)\r\n```js\r\nfunctionsPromise.then(Qx.map)\r\n\t\t\t\t.then(function(results) { ... });\r\n```\r\n\r\n##Array Methods\r\nThese methods can take four different parameters as described above.\r\n\r\n###`.filter()`\r\nLike the native `[].filter()` method, this method returns a promise of an array containing only those items from the original array that pass a filter callback.  If the callback returns a (promise of a) falsy value for an item, that item will not appear in the final array.\r\n\r\nThe resulting array will have the same order as the original array.\r\n\r\n###`.map()`\r\nLike the native `[].map()` method, this method returns a promise of an array of items derived from the original array.  Each element in the resulting array will be the result of calling the callback on the corresponding element in the original array.  As usual, all promises will be resolved and ordering will be preserved.\r\n\r\nThis method can also be used as a `forEach()` method by ignoring return values.\r\n\r\n###`.every()`\r\nLike the native `[].every()` method, this method returns a promise of a boolean indicating whether the callback returned a (promise of a) truthy value for every element in the array.\r\n\r\nIf the callback returns falsy for any element, the resulting promise will be resolved immediately, without waiting for the other promises to complete (although, unlike the short-circuiting `&&` operator, they will always all be evaluated).\r\n\r\nIf the callback fails for some element (or if the original promise fails) before any callback returns true, the resulting promise will fail immediately.  (if a different promise already returned true, the promise will have already succeeded)\r\n\r\n###`.some()`\r\nLike the native `[].some()` method, this method returns a promise of a boolean indicating whether the callback returned a (promise of a) truthy value for at least one element in the array.\r\n\r\nThe returned promise will be resolved as soon as at least one element returns truthy; it will not wait for the promises from the other elements to be resolved (although, unlike the short-circuiting `||` operator, they will always all be evaluated).  If none of elements return truthy, the promise will be resolved to false after all of them finish.\r\n\r\n##Promise methods\r\n###`.any()`\r\nTakes an array of promises, and returns a promise for the result of the first one to succeed.  If all of the promises fail it will return the first failure (but only after all of them fail).\r\n\r\nFor example:\r\n```js \r\nvar possibleUrls = [ 'http://a.example.com', 'http://b.example.com' ];\r\nQx.map(possibleUrls, readUrl)\r\n  .then(Qx.any)\t// Get the first URL to reply\r\n  .then(function(result) { ... });\r\n```\r\n\r\n###`.breakWith()` and `.endFunction`\r\nThese methods allow you to exit a promise chain in the middle.  \r\n\r\nFor example:\r\n\r\n```js\r\nfunction findOrCreateUser(email) {\r\n\treturn store.findUser(email)\r\n\t\t\t\t.then(function(user) {\r\n\t\t\t\t\tif (user)\r\n\t\t\t\t\t\treturn Qx.breakWith(user);\r\n\r\n\t\t\t\t\treturn webService.getAdditionalDetail(email);\r\n\t\t\t\t})\r\n\t\t\t\t.then(function(detail) { \r\n\t\t\t\t\treturn store.createUser(detail);\r\n\t\t\t\t})\r\n\t\t\t\t.fail(Qx.endFunction);\r\n}\r\n```\r\n`Qx.breakWith()` will throw a special marker exception containing the value, which will cause Q to skip all future `.then()` calls.\r\n\r\nAt the end of the method, calling `.fail(Qx.endFunction)` will catch this marker exception and return the value, rethrowing any other errors.\r\n\r\n###`.withBreaks()`\r\nBecause `.breakWith()` is implemented by throwing an exception, any error handlers (`.then(null, function)` or `.fail(function)` will incorrectly see these exceptions as false positives.  \r\nTo fix this, any error callbacks between `.breakWith()` and `.fail(endFunction)` should be wrapped in `Qx.withBreaks()`:\r\n\r\n```js\r\nfunction findOrCreateUser(email) {\r\n\treturn store.findUser(email)\r\n\t\t\t\t.then(function(user) {\r\n\t\t\t\t\tif (user)\r\n\t\t\t\t\t\treturn Qx.breakWith(user);\r\n\r\n\t\t\t\t\treturn webService.getAdditionalDetail(email);\r\n\t\t\t\t})\r\n\t\t\t\t.fail(Qx.withBreaks(function(err) {\r\n\t\t\t\t\treturn fallbackWebService.getAdditionalDetail(email);\r\n\t\t\t\t})\r\n\t\t\t\t.then(function(detail) { \r\n\t\t\t\t\treturn store.createUser(detail);\r\n\t\t\t\t})\r\n\t\t\t\t.fail(Qx.endFunction);\r\n}\r\n```\r\n\r\n\r\n\r\n##TODO\r\n - Async locking primitives (mutexes, reader-writer-locks, sempahores, etc that return delaying promises)\r\n - More array methods (`reduce()`, `sortBy()`, `first()`, `concat()`)\r\n - `Qx.sequenceMap()` that only runs one callback chain at a time\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/SLaks/Qx/issues"
  },
  "_id": "qx@0.2.4",
  "_from": "qx@~0.2.4"
}
